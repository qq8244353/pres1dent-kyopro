[{"id":0,"href":"/pres1dent-kyopro/docs/kaisetuhoso/","title":"Kaisetuhoso","section":"Docs","content":" 解説放送をみたらまとめていく # ABC255 F実装綺麗 初見プレイ "},{"id":1,"href":"/pres1dent-kyopro/docs/haskell/","title":"haskellまとめ","section":"Docs","content":" 入力 # getInt :: IO Int getInt = fst . fromJust . BS.readInt \u0026lt;$\u0026gt; BS.getLine getInts :: IO [Int] getInts = unfoldr (BS.readInt . BS.dropWhile isSpace) \u0026lt;$\u0026gt; BS.getLine 重複除去 # ordはO(N^2). 順序が定義されている場合, O(nlogn)のnubOrdを利用できる.\nNot Equal # /= (equal は ==)\n\u0026lt;$\u0026gt; と \u0026lt;*\u0026gt; # \u0026lt;$\u0026gt; は fmap の略. \u0026lt;*\u0026gt; は \u0026lt;$\u0026gt; の引数が複数ある時に繋げるために使う.\nghci\u0026gt; (*2) \u0026lt;$\u0026gt; [1..3] [2,4,6] ghci\u0026gt; (*) \u0026lt;$\u0026gt; [1 .. 3] \u0026lt;*\u0026gt; [11 .. 13] [11,12,13,22,24,26,33,36,39] 2個目の挙動はいまいちよくわかってない\nlistの結合 # ghci\u0026gt; [1..2] ++ [3..4] [1,2,3,4] flatten # ghci\u0026gt; concat [[1,2],[3,4]] [1,2,3,4] replicateM n # replicateM n でn回アクションをおこなって、結果を配列に入れて返す. (Mはモナドのこと) 例:\ninput1 \u0026lt;- replicateM n getInts input2 \u0026lt;- replicateM n do [u, v] \u0026lt;- getInts // dosomething return (something) pred # pred n で n - 1になる. Enumについて使える\n"},{"id":2,"href":"/pres1dent-kyopro/docs/xor-seisitu/","title":"xorの性質","section":"Docs","content":" 隣合うxor # nが偶数の時 n xor n + 1 = 1\n"},{"id":3,"href":"/pres1dent-kyopro/docs/euclidgojoho/","title":"ユークリッドの互除法","section":"Docs","content":" ユークリッドの互除法 # 概要 # \\[x = y \\times d \u0026#43; m と表せるとき, gcd(x, y) = gcd(y, m)\\] 例題 (ユークリッドの互除法で和を分解) # ABC254 F - Rectangle GCD\n\\( (i,j) \\) の値が \\(A_i \u0026#43; B_j\\) であるとき, \\(1 \\leq h_1, h_2, \\leq H, 1 \\leq w_1, w_2 \\leq W \\) で囲われる短形領域のgcdを求めよ.\n簡単のために \\(h_1 = 1, h_2 = H, w_1 = 1, w_2 = W\\) とする.\n求めるものは, \\[gcd\\Biggr( \\begin{array}{c} gcd(A_1 \u0026#43; B_1, A_1 \u0026#43; B_2, \\cdots, A_1 \u0026#43; B_W), \\\\ gcd( A_2 \u0026#43; B_1, A_2 \u0026#43; B_2, \\cdots, A_2 \u0026#43; B_W), \\\\ \\vdots \\\\ gcd( A_H \u0026#43; B_1, A_H \u0026#43; B_2, \\cdots, A_H \u0026#43; B_W) \\\\ \\end{array} \\Biggr) \\quad (1)\\] \\( A_i \u0026#43; B_j = (A_i \u0026#43; B_{j \u0026#43; 1}) \\times 1 \u0026#43; B_j - B_{j\u0026#43;1} \\) なのでユークリッドの互除法より,\n\\( gcd(A_i \u0026#43; B_j, A_i \u0026#43; B_{j \u0026#43; 1}) = gcd(B_i - B_{j \u0026#43; 1}, A_i \u0026#43; B_{j \u0026#43; 1}) \\) よって,\n\\[\\begin{array}{rl} gcd(A_i \u0026#43; B_1, A_i \u0026#43; B_2, \\cdots, A_i \u0026#43; B_W) \u0026amp; = gcd(B_1 - B_2, A_i \u0026#43; B_2, \\cdots, A_i \u0026#43; B_W) \\\\ \u0026amp; \\vdots \\\\ \u0026amp; = gcd(B_1 - B_2, B_2 - B_3, \\cdots, A_i \u0026#43; B_W) \\\\ \\end{array}\\] 同様にして,\n\\[\\begin{array}{rl} gcd(A_1 \u0026#43; B_W, A_2 \u0026#43; B_W, \\cdots, A_H \u0026#43; B_W) \u0026amp; = gcd(A_1 - A_2, A_2 \u0026#43; B_W, \\cdots, A_H \u0026#43; B_W) \\\\ \u0026amp; \\vdots \\\\ \u0026amp; = gcd(A_1 - A_2, A_2 - A_3, \\cdots, A_H \u0026#43; B_W) \\\\ \\end{array}\\] なので, \\[(1) = gcd(A_1 - A_2, \\cdots, A_{H-1} - A_H, B_1 - B_2, \\cdots, B_{W-1} - B_W, A_H \u0026#43; B_W)\\] これはAとBの区間和なので, セグ木に乗せれば各クエリO(log(H) + log(W) + 1)で解ける\n"},{"id":4,"href":"/pres1dent-kyopro/docs/nijounoki-dp/","title":"二乗の木DP","section":"Docs","content":" 概要 # ぱっと見O(N^3)のDPが実はO(N^2)というやつ.\n記事等 # https://snuke.hatenablog.com/entry/2019/01/15/211812 問題例 # https://atcoder.jp/contests/abc287/tasks/abc287_f\nコード # int main() { ios::sync_with_stdio(false); std::cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector to(n, vector\u0026lt;int\u0026gt;()); rep(i, n - 1) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; a--, b--; to[a].push_back(b); to[b].push_back(a); } auto dfs = [\u0026amp;](auto\u0026amp;\u0026amp; self, int v, int p) -\u0026gt; vector\u0026lt;vector\u0026lt;mint\u0026gt;\u0026gt; { vector dp(2, vector\u0026lt;mint\u0026gt;(2)); dp[0][0] = 1, dp[1][1] = 1; for (auto u : to[v]) { if (u == p) { continue; } auto res = self(self, u, v); vector ndp(dp.size() + res.size(), vector\u0026lt;mint\u0026gt;(2)); rep(i, dp.size()) rep(j, res.size()) { if (i + j \u0026gt;= ndp.size()) { break; } ndp[i + j][0] += dp[i][0] * (res[j][0] + res[j][1]); ndp[i + j][1] += dp[i][1] * res[j][0]; if (i + j - 1 \u0026gt;= 0) { ndp[i + j - 1][1] += dp[i][1] * res[j][1]; } } swap(ndp, dp); } return dp; }; auto res = dfs(dfs, 0, -1); rep(i, n) { if (i + 1 \u0026gt;= res.size()) { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; (res[i + 1][0] + res[i + 1][1]).val() \u0026lt;\u0026lt; endl; } } return 0; } "},{"id":5,"href":"/pres1dent-kyopro/docs/nibuntansaku/","title":"二分探索","section":"Docs","content":" 二分探索 # 値が単調である判定問題に対して, その境界をlog時間で求めるアルゴリズム.\n例えば単調増加な配列について, ある値以上になる最初の要素などを求めることができる.\n応用例 # 問題を解くのに必要な判定問題を考える時, 比較する値が与えられると, それ以上, それ以下などの0, 1情報に変換できることが都合が良かったりする.\n例えば, A_1, A_2, A_n, B_1, B_2, B_n, の数列の積n ^ 2　通りのうちk番目に大きい値を求めよ.\n"},{"id":6,"href":"/pres1dent-kyopro/docs/syazojunisou/","title":"写像12相","section":"Docs","content":" 写像12相 # n 個の区別する玉をk 個の区別しない箱に入れる場合の数（全ての箱に1つ以上）は第2種スターリング数として表されます. 第2種スターリング数は以下の二通りで求めることができます.\n定義から # \\[ S(n, k) = \\frac{1}{k!}\\sum_{i=1}^{k}(-1)^{k-i}{}_kC_ii^n \\] 漸化式から # \\[ S(n, k) = S(n - 1, k - 1) \u0026#43; k * S(n - 1, k) \\] 漸化式で求めるライブラリ # struct stirling { stirling(i64 n) : v(n * (n + 1) / 2) { v[0] = 1; i64 l = 1; for (int i = 1; i \u0026lt; n; i++) { v[l] = 1; for (int j = 1; j \u0026lt; i; j++) { v[l + j] = v[l + j - i - 1] + (j + 1) * v[l + j - i]; } l += i + 1; v[l - 1] = 1; } } i64 get(i64 n, i64 k) const { if (k \u0026gt; n) { return 0; } return v[(n - 1) * n / 2 + k - 1]; } vector\u0026lt;i64\u0026gt; v; }; 第2種スターリング数表 # n\\k 1 2 3 4 5 6 7 8 9 10 11 12 1 1 2 1 1 3 1 3 1 4 1 7 6 1 5 1 15 25 10 1 6 1 31 90 65 15 1 7 1 63 301 350 140 21 1 8 1 127 966 1701 1050 266 28 1 9 1 255 3025 7770 6951 2646 462 36 1 10 1 511 9330 34105 42525 22827 5880 750 45 1 11 1 1023 28501 145750 246730 179487 63987 11880 1155 55 1 12 1 2047 86526 611501 1379400 1323652 627396 159027 22275 1705 66 1 "},{"id":7,"href":"/pres1dent-kyopro/docs/houjogenri/","title":"包除原理","section":"Docs","content":" 包除原理 # 概要 # 包除原理とは以下の性質. \\[|A_1\\cup A_2 \\cup \\cdots \\cup A_n| = \\sum_{k=1}^n(-1)^{k-1} \\sum_{1\\leq i_1 \u0026lt; i_2 \u0026lt; \\cdots \u0026lt; i_k \\leq n} |A_{i_1} \\cap A_{i_2} \\cap \\cdots \\cap A_{i_k}|\\] 包除原理dpのテク # 包助原理とド・モルガンの法則を組み合わせることで以下の式を得る. \\[\\begin{array}{rl} |A_1\\cap A_2 \\cap \\cdots \\cap A_n| \u0026amp;= \\overline{|\\overline{A_1}\\cup \\overline{A_2} \\cup \\cdots \\cup \\overline{A_n}|} \\\\ \u0026amp;= |\\Omega| - |\\overline{A_1}\\cup \\overline{A_2} \\cup \\cdots \\cup \\overline{A_n}| \\\\ \u0026amp;= |\\Omega| - \\displaystyle\\sum_{k=1}^n(-1)^{k-1} \\displaystyle\\sum_{1\\leq i_1 \u0026lt; i_2 \u0026lt; \\cdots \u0026lt; i_k \\leq n} |\\overline{A_{i_1}} \\cap \\overline{A_{i_2}} \\cap \\cdots \\cap \\overline{A_{i_k}}| \\\\ \u0026amp;= |\\Omega| \u0026#43; \\displaystyle\\sum_{k=1}^n(-1)^{k} \\displaystyle\\sum_{1\\leq i_1 \u0026lt; i_2 \u0026lt; \\cdots \u0026lt; i_k \\leq n} |\\overline{A_{i_1}} \\cap \\overline{A_{i_2}} \\cap \\cdots \\cap \\overline{A_{i_k}}| \\\\ \\end{array} \\\\\\] dp配列を以下のように定義すると, ( \\( k = 0\\) のとき,条件がないので全体集合になるのは直感的に正しい.)\n\\[dp[k] = \\Biggl\\{ \\begin{array}{cl} \\displaystyle\\sum_{1\\leq i_1 \u0026lt; i_2 \u0026lt; \\cdots \u0026lt; i_k \\leq n} |\\overline{A_{i_1}} \\cap \\overline{A_{i_2}} \\cap \\cdots \\cap \\overline{A_{i_k}}| \\quad \u0026amp; (k \\geq 1) \\\\ |\\Omega| \u0026amp; (k = 0) \\end{array}\\] 包助原理に関するテクを得る. \\[|A_1\\cap A_2 \\cap \\cdots \\cap A_n| = \\sum_{k=0}^n(-1)^k dp[k]\\] ここの行間理解するの大変だった\n"},{"id":8,"href":"/pres1dent-kyopro/docs/kukan-dp/","title":"区間DP","section":"Docs","content":" 区間DP # 概要 # 2つ合わせて消すみたいな操作の数え上げに使える.\n\\(i, j(i \u0026lt; j)\\) 番目に対して操作するためには \\((j - i) = 0 (mod 2)\\) かつ, \\([i \u0026#43; 1, j - 1]\\) が削除可能であることが必要.\n問題例 # ABC217 F - Make Pair "},{"id":9,"href":"/pres1dent-kyopro/docs/fps/","title":"形式的冪級数","section":"Docs","content":" 形式的冪級数 # 参考リンク集\noptさんのブログアーカイブ hamamuさんのqiita maspyさんblog hamayan tatyam "},{"id":10,"href":"/pres1dent-kyopro/docs/keta-dp/","title":"桁DP","section":"Docs","content":" 桁DP # 桁DPはMLEやTLEを起こしがちなので気を付ける.\n雛形 # int main() { string s; cin \u0026gt;\u0026gt; s; int n = s.size(); // 問題固有な特徴量についての処理を記載する. // dp: 上記の量をキーとするようなdp配列の宣言を記載. // dpではs未満になることが確定したものの情報をもつ. // now: sと一致しているものの状態の宣言を記載. for (int i = 0; i \u0026lt; n; i++) { // ndp: ndpの宣言を記載. int d = s[i] - \u0026#39;0\u0026#39;; // 特徴量について遷移する for (int j = 0; j \u0026lt; dp.size(); j++) { for (int k = 0; k \u0026lt;= 9; k++) { // small to smallの遷移. dp -\u0026gt; ndp } } // same to smallの遷移. now -\u0026gt; ndp for (int k = 0; k \u0026lt; d; k++) { // 最初に0をつけるのは禁止. if (i | k) { // ndp += 1 (sと一致する数は一通り) } } // same to sameの遷移. now -\u0026gt; now // leading-zeroの処理 if (i) { for (int k = 1; k \u0026lt;= 9; k++) { // ndp += 1 } } swap(dp, ndp); } // nowを答えに追加する場合があることに注意する. return 0; } 例題 # 問題 # 1 以上 K 以下の整数のうち、十進表記における各桁の数字の総和が D の倍数であるようなものは何個でしょうか？ 10^9 +7 で割った余りを求めてください。\n解法 # 各桁の和のmod Dを持って桁DPする.\n提出 # https://atcoder.jp/contests/dp/submissions/43926138\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;atcoder/all\u0026gt; using namespace std; using namespace atcoder; using mint = modint1000000007; int main() { ios::sync_with_stdio(false); std::cin.tie(nullptr); string s; cin \u0026gt;\u0026gt; s; int n = s.size(); // 問題固有な特徴量についての処理を記載する. int D; cin \u0026gt;\u0026gt; D; // dp: 上記の量をキーとするようなdp配列の宣言を記載. // dpではs未満になることが確定したものの情報をもつ. vector\u0026lt;mint\u0026gt; dp(D); // now: sと一致しているものの状態の宣言を記載. int now = 0; for (int i = 0; i \u0026lt; n; i++) { // ndp: ndpの宣言を記載. vector\u0026lt;mint\u0026gt; ndp(D); int d = s[i] - \u0026#39;0\u0026#39;; // 特徴量について遷移する for (int j = 0; j \u0026lt; dp.size(); j++) { for (int k = 0; k \u0026lt;= 9; k++) { // small to smallの遷移. dp -\u0026gt; ndp ndp[(j + k) % D] += dp[j]; } } // same to smallの遷移. now -\u0026gt; ndp for (int k = 0; k \u0026lt; d; k++) { // 最初に0をつけるのは禁止. if (i | k) { ndp[(now + k) % D] += 1; } } // same to sameの遷移. now -\u0026gt; now now = (now + d) % D; // leading-zeroの処理 if (i) { for (int k = 1; k \u0026lt;= 9; k++) { // ndp += 1 ndp[k % D] += 1; } } swap(dp, ndp); } // nowを答えに追加する場合があることに注意する. if (!now) { dp[0]++; } cout \u0026lt;\u0026lt; (dp[0]).val() \u0026lt;\u0026lt; endl; return 0; } "},{"id":11,"href":"/pres1dent-kyopro/docs/chochoten/","title":"超頂点","section":"Docs","content":" 超頂点 # 概要 # グループを代表する頂点を作ることで、グループ内の辺を作らなくて良くなるテク\n問題例\nABC302 F - Merge Set "},{"id":12,"href":"/pres1dent-kyopro/docs/tekisetunimaekeisan/","title":"適切に前計算する","section":"Docs","content":" 何日連続勤務したときいくらの生産量が得られるかを前もって計算する # https://atcoder.jp/contests/abc285/tasks/abc285_e\n"},{"id":13,"href":"/pres1dent-kyopro/docs/bubunretudp/","title":"部分列DP","section":"Docs","content":" 部分列DP # 概要 # 文字列の部分列を数え上げる. 同じ文字が現れるとき, どれを経由しても同じ文字になるがこれを区別して同じ文字を重複して数えないように, どの文字を最後に使ったか区別して, そのうちの一つから遷移するようにする.\nリンク集\nけんちょんさん noshiさん 問題集\nABC214 F Substrings ABC299 F Square Subsequence ABC230 F Predilection TDPC G 辞書順 ARC081 E Don\u0026rsquo;t Be a Subsequence "}]