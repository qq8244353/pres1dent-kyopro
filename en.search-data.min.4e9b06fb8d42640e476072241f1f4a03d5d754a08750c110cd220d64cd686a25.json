[{"id":0,"href":"/pres1dent-kyopro/docs/euclidgojoho/","title":"ユークリッドの互除法","section":"Docs","content":" ユークリッドの互除法 # 概要 # \\[x = y \\times d \u0026#43; m と表せるとき, gcd(x, y) = gcd(y, m)\\] 例題 (ユークリッドの互除法で和を分解) # ABC254 F - Rectangle GCD\n\\( (i,j) \\) の値が \\(A_i \u0026#43; B_j\\) であるとき, \\(1 \\leq h_1, h_2, \\leq H, 1 \\leq w_1, w_2 \\leq W \\) で囲われる短形領域のgcdを求めよ.\n簡単のために \\(h_1 = 1, h_2 = H, w_1 = 1, w_2 = W\\) とする.\n求めるものは, \\[gcd\\Biggr( \\begin{array}{c} gcd(A_1 \u0026#43; B_1, A_1 \u0026#43; B_2, \\cdots, A_1 \u0026#43; B_W), \\\\ gcd( A_2 \u0026#43; B_1, A_2 \u0026#43; B_2, \\cdots, A_2 \u0026#43; B_W), \\\\ \\vdots \\\\ gcd( A_H \u0026#43; B_1, A_H \u0026#43; B_2, \\cdots, A_H \u0026#43; B_W) \\\\ \\end{array} \\Biggr) \\quad (1)\\] \\( A_i \u0026#43; B_j = (A_i \u0026#43; B_{j \u0026#43; 1}) \\times 1 \u0026#43; B_j - B_{j\u0026#43;1} \\) なのでユークリッドの互除法より,\n\\( gcd(A_i \u0026#43; B_j, A_i \u0026#43; B_{j \u0026#43; 1}) = gcd(B_i - B_{j \u0026#43; 1}, A_i \u0026#43; B_{j \u0026#43; 1}) \\) よって,\n\\[\\begin{array}{rl} gcd(A_i \u0026#43; B_1, A_i \u0026#43; B_2, \\cdots, A_i \u0026#43; B_W) \u0026amp; = gcd(B_1 - B_2, A_i \u0026#43; B_2, \\cdots, A_i \u0026#43; B_W) \\\\ \u0026amp; \\vdots \\\\ \u0026amp; = gcd(B_1 - B_2, B_2 - B_3, \\cdots, A_i \u0026#43; B_W) \\\\ \\end{array}\\] 同様にして,\n\\[\\begin{array}{rl} gcd(A_1 \u0026#43; B_W, A_2 \u0026#43; B_W, \\cdots, A_H \u0026#43; B_W) \u0026amp; = gcd(A_1 - A_2, A_2 \u0026#43; B_W, \\cdots, A_H \u0026#43; B_W) \\\\ \u0026amp; \\vdots \\\\ \u0026amp; = gcd(A_1 - A_2, A_2 - A_3, \\cdots, A_H \u0026#43; B_W) \\\\ \\end{array}\\] なので, \\[(1) = gcd(A_1 - A_2, \\cdots, A_{H-1} - A_H, B_1 - B_2, \\cdots, B_{W-1} - B_W, A_H \u0026#43; B_W)\\] これはAとBの区間和なので, セグ木に乗せれば各クエリO(log(H) + log(W) + 1)で解ける\n"},{"id":1,"href":"/pres1dent-kyopro/docs/nibuntansaku/","title":"二分探索","section":"Docs","content":" 二分探索 # 値が単調である判定問題に対して, その境界をlog時間で求めるアルゴリズム.\n例えば単調増加な配列について, ある値以上になる最初の要素などを求めることができる.\n応用例 # 問題を解くのに必要な判定問題を考える時, 比較する値が与えられると, それ以上, それ以下などの0, 1情報に変換できることが都合が良かったりする.\n例えば, A_1, A_2, A_n, B_1, B_2, B_n, の数列の積n ^ 2　通りのうちk番目に大きい値を求めよ.\n"},{"id":2,"href":"/pres1dent-kyopro/docs/syazojunisou/","title":"写像12相","section":"Docs","content":" 写像12相 # n 個の区別する玉をk 個の区別しない箱に入れる場合の数（全ての箱に1つ以上）は第2種スターリング数として表されます. 第2種スターリング数は以下の二通りで求めることができます.\n定義から # \\[ S(n, k) = \\frac{1}{k!}\\sum_{i=1}^{k}(-1)^{k-i}{}_kC_ii^n \\] 漸化式から # \\[ S(n, k) = S(n - 1, k - 1) \u0026#43; k * S(n - 1, k) \\] 漸化式で求めるライブラリ # struct stirling { stirling(i64 n) : v(n * (n + 1) / 2) { v[0] = 1; i64 l = 1; for (int i = 1; i \u0026lt; n; i++) { v[l] = 1; for (int j = 1; j \u0026lt; i; j++) { v[l + j] = v[l + j - i - 1] + (j + 1) * v[l + j - i]; } l += i + 1; v[l - 1] = 1; } } i64 get(i64 n, i64 k) const { if (k \u0026gt; n) { return 0; } return v[(n - 1) * n / 2 + k - 1]; } vector\u0026lt;i64\u0026gt; v; }; 第2種スターリング数表 # n\\k 1 2 3 4 5 6 7 8 9 10 11 12 1 1 2 1 1 3 1 3 1 4 1 7 6 1 5 1 15 25 10 1 6 1 31 90 65 15 1 7 1 63 301 350 140 21 1 8 1 127 966 1701 1050 266 28 1 9 1 255 3025 7770 6951 2646 462 36 1 10 1 511 9330 34105 42525 22827 5880 750 45 1 11 1 1023 28501 145750 246730 179487 63987 11880 1155 55 1 12 1 2047 86526 611501 1379400 1323652 627396 159027 22275 1705 66 1 "},{"id":3,"href":"/pres1dent-kyopro/docs/houjogenri/","title":"包除原理","section":"Docs","content":" 包除原理 # 概要 # 包除原理とは以下の性質. \\[|A_1\\cup A_2 \\cup \\cdots \\cup A_n| = \\sum_{k=1}^n(-1)^{k-1} \\sum_{1\\leq i_1 \u0026lt; i_2 \u0026lt; \\cdots \u0026lt; i_k \\leq n} |A_{i_1} \\cap A_{i_2} \\cap \\cdots \\cap A_{i_k}|\\] 包除原理dpのテク # 包助原理とド・モルガンの法則を組み合わせることで以下の式を得る. \\[\\begin{array}{rl} |A_1\\cap A_2 \\cap \\cdots \\cap A_n| \u0026amp;= \\overline{|\\overline{A_1}\\cup \\overline{A_2} \\cup \\cdots \\cup \\overline{A_n}|} \\\\ \u0026amp;= |\\Omega| - |\\overline{A_1}\\cup \\overline{A_2} \\cup \\cdots \\cup \\overline{A_n}| \\\\ \u0026amp;= |\\Omega| - \\displaystyle\\sum_{k=1}^n(-1)^{k-1} \\displaystyle\\sum_{1\\leq i_1 \u0026lt; i_2 \u0026lt; \\cdots \u0026lt; i_k \\leq n} |\\overline{A_{i_1}} \\cap \\overline{A_{i_2}} \\cap \\cdots \\cap \\overline{A_{i_k}}| \\\\ \u0026amp;= |\\Omega| \u0026#43; \\displaystyle\\sum_{k=1}^n(-1)^{k} \\displaystyle\\sum_{1\\leq i_1 \u0026lt; i_2 \u0026lt; \\cdots \u0026lt; i_k \\leq n} |\\overline{A_{i_1}} \\cap \\overline{A_{i_2}} \\cap \\cdots \\cap \\overline{A_{i_k}}| \\\\ \\end{array} \\\\\\] dp配列を以下のように定義すると, ( \\( k = 0\\) のとき,条件がないので全体集合になるのは直感的に正しい.)\n\\[dp[k] = \\Biggl\\{ \\begin{array}{cl} \\displaystyle\\sum_{1\\leq i_1 \u0026lt; i_2 \u0026lt; \\cdots \u0026lt; i_k \\leq n} |\\overline{A_{i_1}} \\cap \\overline{A_{i_2}} \\cap \\cdots \\cap \\overline{A_{i_k}}| \\quad \u0026amp; (k \\geq 1) \\\\ |\\Omega| \u0026amp; (k = 0) \\end{array}\\] 包助原理に関するテクを得る. \\[|A_1\\cap A_2 \\cap \\cdots \\cap A_n| = \\sum_{k=0}^n(-1)^k dp[k]\\] ここの行間理解するの大変だった\n"},{"id":4,"href":"/pres1dent-kyopro/docs/fps/","title":"形式的冪級数","section":"Docs","content":" 形式的冪級数 # 参考リンク集\noptさんのブログアーカイブ hamamuさんのqiita maspyさんblog hamayan tatyam "},{"id":5,"href":"/pres1dent-kyopro/docs/chochoten/","title":"超頂点","section":"Docs","content":" 超頂点 # 概要 # グループを代表する頂点を作ることで、グループ内の辺を作らなくて良くなるテク\n問題例\n- ABC302 F - Merge Set\n"}]